sqlite3>
  two primary objects of sqlite3 :
    sqlite3  ->  the database connection object,created by sqlite3_open(),
    	     	 and destroyed by sqlite3_close().

		 typedef struct sqlite3 sqlite3;

		 each open SQLite database is represented by a pointer to an
		 instance of the opaque structure named "sqlite3".

		 constructors :
		   sqlite3_open(), sqlite3_open16(), sqlite3_open_v2()

		 destructors :
		   sqlite3_close(), sqlite3_close_v2()

    sqlite3_stmt  ->  the prepared statement object,created by sqlite3_prepare(),
    		      and destroyed by sqlite3_finalize().

		      typedef struct sqlite3_stmt sqlite3_stmt;

		      an instance of this object represents a single SQL statement
		      that has been compiled into binary form and is ready to be
		      evaluated.

		      constructors :
		        sqlite3_prepare(), sqlite3_prepare16(), sqlite3_prepare16_v2()
			sqlite3_prepare16_v3(), sqlite3_prepare_v2(), sqlite3_prepare_v3()
			
		      destructor :
		        sqlite3_finalize()

  eight primary methods of sqlite3 :
    /*  sqlite3_open - open an SQLite database file with UTF-8.
     *  @filename : sqlite3 database filename with full path or relative path.
     *  @ppDb : the pointer points to a pointer which points to a sqlite3 object.
     *  return - SQLITE_OK or error code.
     *  #  this function will automatically allocate memory for *ppDb,if failed to
     	   allocating,then NULL will be written into it.
     */
    int sqlite3_open(const char *filename, sqlite3 **ppDb);

    /*  sqlite3_open16 - UTF-16 version.  */
    int sqlite3_open16(const void *filename, sqlite3 **ppDb);

    /*  sqlite3_open_v2 - works like sqlite3_open() except that it accepts two
     *                    additional parameters for additonal control over the
     *                    new database connection.(UTF-8)
     *  @filename : file name.
     *  @ppDb : pointer of pointer points to sqlite3.
     *  @flags : at least one of the following flags must be included >
     *             SQLITE_OPEN_READONLY
     *             SQLITE_OPEN_READWRITE
     *		   SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE
     *		   SQLITE_OPEN_URI	 /*  the filename can be interpreted as a URI  */
     *		   SQLITE_OPEN_MEMORY	 /*  database will be opened as an in-memory database  */
     *		   			 /*  it is named by @filename,used for cache-sharing  */
     *		   SQLITE_OPEN_NOMUTEX
     *		   SQLITE_OPEN_FULLMUTEX
     *		   SQLITE_OPEN_SHAREDCACHE
     *		   SQLITE_OPEN_PRIVATECACHE	/*  shared cache disabled  */
     *		   SQLITE_OPEN_EXRESCODE	/*  extended result code mode  */
     *		   SQLITE_OPEN_NOFOLLOW		/*  @filename is not allowed to contain a symbolic link  */
     *  @zVfs : the name of the sqlite3_vfs object that defines the operating
     *	      	system interface that the new database connection should use.
     *  return - SQLITE_OK or error code.
     *  #  SQLITE_OPEN_EXCLUSIVE flag does not cause the open to fail if the 
     *	   databse already exists,it is intended for use by the VFS interface only.
     *  #  if @flags is not a optionally combining from above,the behavior is undefined.
     */
    int sqlite3_open_v2(const char *filename, sqlite3 **ppDb,
    			int flags, const char *zVfs);

    /*  sqlite3_close - close a database connection and destroy it.
     *  @db : pointer returned by sqlite3_open() or sqlite3_open16().
     *  return - SQLITE_OK or error code.
     *  #  if the database connection is associated with unfinalized prepared statements,
     	   BLOB handlers,and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return SQLITE_BUSY.
     */
    int sqlite3_close(sqlite3 *db);

    /*  sqlite3_close_v2 - for close and destroy a connection opened by sqlite3_open_v2().  */
    int sqlite3_close_v2(sqlite3 *db);

    !  if an sqlite3 object is destroyed while a transaction is open,the transaction
       is automatically rolled back.
    !  @db can not previously closed,call close functions with NULL is a harmless no-op.

  Compiling An SQL Statement>

    /*  sqlite3_prepare - routine used for convert SQL statement in UTF-8 to byte-code program.
     *  @db : database instance.
     *  @zSql : the SQL statement to be compiled.
     *  @nByte : read up indicator,@nByte < 0,the first '\0' as end;
     *                             @nByte > 0,the maximum number of characters
     *                             to be readed.
     *  @ppStmt : *ppStmt points to the compiled SQL statement.
     *  @pzTail : if @pzTail is not NULL,then *pzTail will points to the first
     *            byte past the end of the first SQL statement in @zSql.
     *            *pzTail is left pointing to what remains uncompiled.
     *  return - SQLITE_OK or error code.
     */
    int sqlite3_prepare(sqlite3 *db, const char *zSql, int nByte,
    		        sqlite3_stmt **ppStmt, const char **pzTail);

    /*  sqlite3_prepare_v2 - version 2,recommended for all new programs.  */
    int sqlite3_prepare_v2(sqlite3 *db, const char *zSql, int nByte,
    			   sqlite3_stmt **ppStmt, const char **pzTail);

    /*  sqlite3_prepare_v3 - version 3.
     *  @prepFlags : a bit array consisting of zero or more of the SQLITE_PREPARE_* flags.
     *               if @preFlags is zero,then this function is same to *_v2 functions.
     */
    int sqlite3_prepare_v3(sqlite3 *db, const char *zSql, int nByte,
    			   unsigned int prepFlags, sqlite3_stmt **ppStmt,
			   const char **pzTail);

    /*  In the "vX" interfaces,the prepared statement that is returned contains a
        copy of the original SQL text,this causes the sqlite3_setp() interface to behave
	differently in 3 ways :
	  >  if the database schema changes,instead of returning SQLITE_SCHEMA
	     as it always used to do,sqlite3_setp() will automatically recompile
	     the SQL statement and try to run it again.
	     as many as SQLITE_MAX_SCHEMA_RETRY retries will occur before sqlite3_step()
	     gives up and returns an error.
	  >  when an error occurs,sqlite3_step() will return one of the detailed
	     error codes or extended error codes.
	     the legacy behavior was that sqlite3_step() would only return a generic
	     SQLITE_ERROR result code and the application would have to make a 
	     second call to sqlite3_reset() in order to find the underlying cause
	     of the problem.with the "v2" prepare interfaces,the underlying reason
	     for the error is returned immediately.
	  >  if the specific value bound to a host parameter in the WHERE clause
	     might influence the choice of query plan for a statement,then the statement
	     will be automatically recompiled,as if there had been a schema change,
	     on the first sqlite3_setp() call following any change to the bindings
	     of that parameter.the specific value of a WHERE-clause parameter might
	     influence the choice of query plan if the parameter is the left-hand
	     side of a LIKE or GLOB operator or if the parameter is compared to
	     an indexed column and the SQLITE_ENABLE_STAT4 compile-time option
	     is enabled.
    */

    /*  UTF-16 version  */
    int sqlite3_prepare16(sqlite3 *db, const void *zSql, int nByte,
    		          sqlite3_stmt **ppStmt, const void **pzTail);
    
    /*  UTF-16 version  */
    int sqlite3_prepare16_v2(sqlite3 *db, const void *zSql, int nByte,
    			     sqlite3_stmt **ppStmt, const void **pzTail);

    /*  UTF-16 version  */
    int sqlite3_prepare16_v3(sqlite3 *db, const void *zSql, int nByte,
    		             unsigned int prepFlags, sqlite3_stmt **ppStmt,
			     const void **pzTail);

  Binding Values To Prepared Statements>
    int sqlite3_bind_blob(sqlite3_stmt *, int, const void *, int n,
    			  void (*)(void *));
    int sqlite3_bind_blob64(sqlite3_stmt *, int, const void *, sqlite3_unit64,
    			    void (*)(void *));

    int sqlite3_bind_double(sqlite3_stmt *, int, double);
    
    int sqlite3_bind_int(sqlite3_stmt *, int, int);

    int sqlite3_bind_int64(sqlite3_stmt *, int, sqlite3_int64);

    int sqlite3_bind_null(sqlite3_stmt *, int);

    int sqlite3_bind_text(sqlite3_stmt *, int, const char *, int,
    			  void (*)(void *));

    int sqlite3_bind_text16(sqlite3_stmt *, int, const void *, int,
    			    void (*)(void *));
    int sqlite3_bind_text64(sqlite3_stmt *, int, const char *, sqlite3_uint64,
    	                    void (*)(void *), unsigned char encoding);

    int sqlite3_bind_value(sqlite3_stmt *, int, const sqlite3_value *);

    int sqlite3_bind_pointer(sqlite3_stmt *, int, void *, const char *,
    	                     void (*)(void*));

    int sqlite3_bind_zeroblob(sqlite3_stmt *, int, int n);
    int sqlite3_bind_zeroblob64(sqlite3_stmt *, int, sqlite3_uint64);

    #  in the SQL statement text input to sqlite3_prepare_v2() and its variants,
       literals may be replaced by a parameter that matches one of following templates :
         (literal templates)
         ?
	 ?NNN	/*  NNN represents an integer literal  */
	 :VVV	/*  VVV represents an alphanumeric identifier  */
	 @VVV
	 $VVV

       the values of these parameters can be set using the sqlite3_bind_*() routines.

       e.g.
         INSERT INTO TABLE_NAME (field1, field2) VALUES(?1, ?2)
	 this statment have to be prepared by sqlite3_prepare_*() as first before 
	 parameter binding.

    1st-arg :
      always a pointer to the sqlite3_stmt object returned from sqlite3_prepare_v2() or
      its variants.

    2nd-arg :
      the index of the SQL parameter to be set.the leftmost SQL parameter has
      an index of 1,when the same named SQL parameter is used more than once,
      second and subsequent occurrences have the same index as the first occurrence.
      the index for named parameters can be looked up using the sqlite3_bind_parameter_index() API.
      the index for "?NNN" parameters is the value of NNN,the NNN value must be
      between 1 and the sqlite3_limit() parameter SQLITE_LIMIT_VARIABLE_NUMBER.

    3rd-arg :
      the value to bind to the parameter,NULL pointer the fourth parameter is ignored,
      and the end result is the same as sqlite3_bind_null().

    4th-arg :
      its value is the number of bytes in the parameter,in other words,
      the value is the number of bytes in the value,not the number of characters.(do not contain '\0')
      if it is negative to sqlite3_bind_text() or sqlite3_bind_text16(),then the
      length of the string is the number of bytes up to the first zero terminator.
      if it is negative to sqlite3_bind_blob().then the behavior is undefined.
      if any NUL characters occurs at byte offsets less than the value of the 4th
      parameter then the resulting string value will contain embedded NULs.
      the result of expressions involving strings with embedded NULs is undefined.

    5th-arg :
      5th-arg to the BLOB and string binding interfaces constrols or indicates the
      lifetime of the object referenced by the 3rd parameter.
      three options exist :
        1>  A destructor to dispose of the BLOB or string after SQLite has finished
	    with it may be passed.(bind API fails,still call to destructor)
	    (if 3rd-arg is NULL,destructor would not be called)
	2>  the special constant SQLITE_STATIC,may be passed to indicate that the
	    application remains resonsible for disposing of the object.
	3>  the constant SQLITE_TRANSIENT,may be passed to indicate that the object
	    is to be copied prior to the return from sqlite3_bind_*().
	    SQLite will then manage the lifetime of its private copy.

    6th-arg :
      6th-arg to sqlite3_bind_text64() must be one of SQLITE_UTF8,SQLITE_UTF16,
      SQLITE_UTF16BE,SQLITE_UTF16LE to specify the encoding of the text in the
      3rd parameter.
      if 6th-arg != @these_values or if the text encoding is different from
      the encoding specified by the 6th parameter,then the behavior is undefined.

    sqlite3_bind_zeroblob() binds a BLOB of length N that is filled with zeros.

    sqlite3_bind_pointer(S,I,P,T,D) causes the @I-th parameter in prepared statement
    @S to have an SQL value of NULL,but to also be associated with the pointer @P of type @T,
    @D is either a NULL pointer or a pointer to a destructor for @P.

    !  if @prepared_statement is NULL or it is a prepared statement for which
       sqlite3_step() has been called more recently than sqlite3_reset(),then the
       call will return SQLITE_MISUSE.
       if @prepared_statement has been finalized,the result is undefined and
       probably harmful.
    !  bindings are not cleared by the sqlite3_reset().unbound parameters are 
       interpreted as NULL.
       sqlite3_clear_bindings()API will cleared bindings.

    #  the byte-order of UTF16 input text is determined by the byte-order mark(BOM,U+FEFF).
       if the mark is uncorrect or missed,SQLite might change those invalid characters into
       the unicode replacement character: U+FFFD.
      

    

